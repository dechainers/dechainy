{
  "plugins": [
    "mitigator",
    "adaptmon"
  ],
  "clusters": [
    {
      "name": "cluster1",
      "time_window": 10,
      "cp_function": "# Copyright 2020 DeChainy\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport json\n\nfrom dechain.configurations import MitigatorRule\nfrom dechain.plugins import Cluster\nfrom dechain.utility import ipv4_to_string\n\ncounter: int = 0\n\n\ndef reaction_function_rest(cluster: Cluster):\n    global counter\n    counter += 1\n\n    cnt_ingress = cluster['adaptmon']['pkt_counter'][\"ingress\"]['TOTAL_PACKETS'][0].value\n    cnt_egress = cluster['adaptmon']['pkt_counter'][\"egress\"]['TOTAL_PACKETS'][0].value\n    rules = {}\n    # NB: it is possible to call the probe specific control plane method instead of directly\n    #     accessing the map. Thus, pay attention to what you do.\n    for key, cnt in cluster['mitigator']['probe'][\"ingress\"]['BLACKLISTED_IPS'].items():\n        rules[f\"{ipv4_to_string(key.ip)}/{key.netmask_len}\"] = cnt.value\n\n    return {\n        'pkt_ingress': cnt_ingress,\n        'pkt_egress': cnt_egress,\n        'mitigator_rules': rules}\n\n\ndef reaction_function(cluster: Cluster):\n    global counter\n\n    ret = reaction_function_rest(cluster)\n\n    print('------------------------------\\n'\n          f'Packet Counter: Ingress({ret[\"pkt_ingress\"]}) Egress({ret[\"pkt_egress\"]})\\n'\n          f'Mitigator: {json.dumps(ret[\"mitigator_rules\"], indent=2)}')\n\n    if ret['pkt_ingress'] > 10 and not ret['mitigator_rules']:\n        print('Filling map with rule')\n        # NB: it is possible to directly access the eBPF map, but then the rule would not be pushed into\n        #     the Python class. Thus, pay attention to what you do.\n        cluster[\"mitigator\"][\"probe\"].insert(MitigatorRule({\"netmask\": 32, \"ip\": \"8.8.8.8\"}))\n    print('', flush=True)\n",
      "probes": [
        {
          "plugin": "adaptmon",
          "name": "pkt_counter",
          "mode": "XDP",
          "interface": "wlp59s0",
          "ingress": "// Copyright 2020 DeChainy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nBPF_TABLE(\"array\", int, uint64_t, TOTAL_PACKETS, 1);\n\nstatic __always_inline\nint handler(struct CTXTYPE *ctx, struct pkt_metadata *md) {\n    void *data = (void *) (long) ctx->data;\n    void *data_end = (void *) (long) ctx->data_end;\n\n   /*Parsing L2*/\n    struct eth_hdr *ethernet = data;\n    if (data + sizeof(*ethernet) > data_end)\n        return PASS;\n\n    if (ethernet->proto != bpf_htons(ETH_P_IP))\n        return PASS;\n\n    /*Parsing L3*/\n    struct iphdr *ip = data + sizeof(struct eth_hdr);\n    if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n        return PASS;\n\n    TOTAL_PACKETS.increment(0);\n\n    return PASS;\n}",
          "egress": "// Copyright 2020 DeChainy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nBPF_TABLE(\"array\", int, uint64_t, TOTAL_PACKETS, 1);\n\nstatic __always_inline\nint handler(struct CTXTYPE *ctx, struct pkt_metadata *md) {\n    void *data = (void *) (long) ctx->data;\n    void *data_end = (void *) (long) ctx->data_end;\n\n   /*Parsing L2*/\n    struct eth_hdr *ethernet = data;\n    if (data + sizeof(*ethernet) > data_end)\n        return PASS;\n\n    if (ethernet->proto != bpf_htons(ETH_P_IP))\n        return PASS;\n\n    /*Parsing L3*/\n    struct iphdr *ip = data + sizeof(struct eth_hdr);\n    if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n        return PASS;\n\n    TOTAL_PACKETS.increment(0);\n\n    return PASS;\n}",
          "cp_function": "# Copyright 2020 DeChainy\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom dechainy.plugins import Plugin\n\n\ndef reaction_function_rest(probe: Plugin):\n    return {'ingress': probe[\"ingress\"]['TOTAL_PACKETS'][0].value,\n            'egress': probe[\"egress\"]['TOTAL_PACKETS'][0].value}\n\n\ndef reaction_function(probe: Plugin):\n    print(reaction_function_rest(probe), flush=True)\n"
        },
        {
          "plugin": "mitigator",
          "name": "probe",
          "mode": "XDP",
          "interface": "wlp59s0"
        }
      ]
    }
  ],
  "probes": [
    {
      "plugin": "adaptmon",
      "name": "statistics_gatherer",
      "mode": "XDP",
      "interface": "wlp59s0",
      "time_window": 5,
      "ingress": "// Copyright 2020 DeChainy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/*Protocol types according to the standard*/\n#define IPPROTO_TCP 6\n#define IPPROTO_UDP 17\n\n/* Number of max TCP session tracked */\n#define N_SESSION 10000\n\n/*Features to be exported*/\nstruct features {\n    //Real features\n    uint64_t n_packets;                             // Number of packets on one direction\n    uint64_t n_packets_reverse;                     // Number of packets on opposite direction\n    uint64_t n_bytes;                               // Total bytes on one direction\n    uint64_t n_bytes_reverse;                       // Total bytes on opposite direction\n    uint64_t start_timestamp;                       // Connection begin timestamp\n    uint64_t alive_timestamp;                       // Last message received timestamp\n    uint32_t server_ip;                             // The IP of the server\n    uint32_t method;                                // The method used to determine the server\n} __attribute__((packed));\n\n/*Session identifier*/\nstruct session_key {\n    __be32 saddr;                                   //IP source address\n    __be32 daddr;                                   //IP dest address\n    __be16 sport;                                   //Source port\n    __be16 dport;                                   //Dest port\n    __u8   proto;                                   //Protocol ID\n} __attribute__((packed));\n\n/*Tracked session map*/\n#if PTYPE == 0\nBPF_TABLE_SHARED(\"percpu_hash\", struct session_key, struct features, SESSIONS_TRACKED_CRYPTO, N_SESSION);\n#else\nBPF_TABLE(\"extern\", struct session_key, struct features, SESSIONS_TRACKED_CRYPTO, N_SESSION);\n#endif\n\n/*Method to return the session identifier, with the lower IP as first member*/\nstatic __always_inline struct session_key get_key(uint32_t ip_a, uint32_t ip_b, uint16_t port_a, uint16_t port_b, uint8_t proto) {\n  if(ip_a < ip_b) {\n    struct session_key ret = {.saddr=ip_a, .daddr=ip_b, .sport=port_a, .dport=port_b, .proto=proto};\n    return ret;\n  } else {\n    struct session_key ret = {.saddr=ip_b, .daddr=ip_a, .sport=port_b, .dport=port_a, .proto=proto};\n    return ret;\n  }\n}\n\n/*Method to determine which member of the communication is the server*/\nstatic __always_inline __be32 heuristic_server(uint32_t src_ip, uint32_t dst_ip, uint16_t src_port, uint16_t dst_port, uint32_t *method, struct tcphdr *tcp) {\n  /*If Syn, then srcIp is the server*/\n  if(tcp && tcp->syn) {/*If source port < 1024, then srcIp is the server*/\n    *method = 1;\n    return tcp->ack? src_ip : dst_ip;\n  }\n  dst_port = bpf_htons(dst_port);\n  /*If destination port < 1024, then dstIp is the server*/\n  if(dst_port < 1024) {\n    *method = 2;\n    return dst_ip;\n  }\n  src_port = bpf_htons(src_port);\n  /*If source port < 1024, then srcIp is the server*/\n  if(src_port < 1024) {\n    *method = 2;\n    return src_ip;\n  }\n  *method = 3;\n  /*Otherwise, the lowest port is the server*/\n  return dst_port <= src_port ? dst_ip : src_ip;\n}\n\nstatic __always_inline void do_update(struct features *value, uint64_t len, uint64_t curr_time, bool cond) {\n  if (cond) {\n    value->n_packets += 1;\n    value->n_bytes += len;\n  } else {\n    value->n_packets_reverse += 1;\n    value->n_bytes_reverse += len;\n  }\n  value->alive_timestamp = curr_time;\n}\n\n\nstatic __always_inline int handler(struct CTXTYPE *ctx, struct pkt_metadata *md) {\n  void *data = (void *) (long) ctx->data;\n  void *data_end = (void *) (long) ctx->data_end;\n\n  /*Parsing L2*/\n  struct eth_hdr *ethernet = data;\n  if (data + sizeof(*ethernet) > data_end)\n    return PASS;\n\n  if (ethernet->proto != bpf_htons(ETH_P_IP))\n    return PASS;\n\n  /*Parsing L3*/\n  struct iphdr *ip = data + sizeof(struct eth_hdr);\n  if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n    return PASS;\n  if ((int) ip->version != 4)\n    return PASS;\n\n  /*Calculating ip header length\n   * value to multiply by 4 (SHL 2)\n   *e.g. ip->ihl = 5 ; TCP Header starts at = 5 x 4 byte = 20 byte */\n  uint8_t ip_header_len = ip->ihl << 2;\n\n  switch (ip->protocol) {\n    case IPPROTO_TCP: {\n      /*Parsing L4 TCP*/\n      struct tcphdr *tcp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) tcp + sizeof(*tcp) > data_end) {\n        return PASS;\n      }\n\n      uint64_t curr_time = get_time_epoch();\n      struct session_key key = get_key(ip->saddr, ip->daddr, tcp->source, tcp->dest, ip->protocol);\n\n      /*Check if match*/\n      struct features *value = SESSIONS_TRACKED_CRYPTO.lookup(&key);\n      if (!value) {\n        uint32_t method;\n        uint32_t server_ip = heuristic_server(ip->saddr, ip->daddr, tcp->source, tcp->dest, &method, tcp);\n        struct features zero = {.start_timestamp=curr_time, .method=method, .server_ip=server_ip};\n        SESSIONS_TRACKED_CRYPTO.insert(&key, &zero);\n        value = SESSIONS_TRACKED_CRYPTO.lookup(&key);\n        if (!value) {\n          return PASS;\n        }\n      }\n\n      /*Update current session*/\n      do_update(value, bpf_ntohs(ip->tot_len), curr_time, ip->saddr == key.saddr);\n      break;\n    }\n    case IPPROTO_UDP: {\n      /*Parsing L4 UDP*/\n      struct udphdr *udp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) udp + sizeof(*udp) > data_end) {\n        return PASS;\n      }\n\n      uint64_t curr_time = get_time_epoch();\n      struct session_key key = get_key(ip->saddr, ip->daddr, udp->source, udp->dest, ip->protocol);\n\n      /*Check if match*/\n      struct features *value = SESSIONS_TRACKED_CRYPTO.lookup(&key);\n      if (!value) {\n        uint32_t method;\n        uint32_t server_ip = heuristic_server(ip->saddr, ip->daddr, udp->source, udp->dest, &method, NULL);\n        struct features zero = {.start_timestamp=curr_time, .method=method, .server_ip=server_ip};\n        SESSIONS_TRACKED_CRYPTO.insert(&key, &zero);\n        value = SESSIONS_TRACKED_CRYPTO.lookup(&key);\n        if (!value) {\n          return PASS;\n        }\n      }\n\n      /*Update current session*/\n      do_update(value, bpf_ntohs(ip->tot_len), curr_time, ip->saddr == key.saddr);\n      break;\n    }\n    /*Ignored protocols*/\n    default: {\n      return PASS;\n    }\n  }\n\n  /* Here operations after the capture */\n  return PASS;\n}\n",
      "egress": "// Copyright 2020 DeChainy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/*Protocol types according to the standard*/\n#define IPPROTO_TCP 6\n#define IPPROTO_UDP 17\n\n/* Number of max TCP session tracked */\n#define N_SESSION 10000\n\n/*Features to be exported*/\nstruct features {\n    //Real features\n    uint64_t n_packets;                             // Number of packets on one direction\n    uint64_t n_packets_reverse;                     // Number of packets on opposite direction\n    uint64_t n_bytes;                               // Total bytes on one direction\n    uint64_t n_bytes_reverse;                       // Total bytes on opposite direction\n    uint64_t start_timestamp;                       // Connection begin timestamp\n    uint64_t alive_timestamp;                       // Last message received timestamp\n    uint32_t server_ip;                             // The IP of the server\n    uint32_t method;                                // The method used to determine the server\n} __attribute__((packed));\n\n/*Session identifier*/\nstruct session_key {\n    __be32 saddr;                                   //IP source address\n    __be32 daddr;                                   //IP dest address\n    __be16 sport;                                   //Source port\n    __be16 dport;                                   //Dest port\n    __u8   proto;                                   //Protocol ID\n} __attribute__((packed));\n\n/*Tracked session map*/\n#if PTYPE == 0\nBPF_TABLE_SHARED(\"percpu_hash\", struct session_key, struct features, SESSIONS_TRACKED_CRYPTO, N_SESSION);\n#else\nBPF_TABLE(\"extern\", struct session_key, struct features, SESSIONS_TRACKED_CRYPTO, N_SESSION);\n#endif\n\n/*Method to return the session identifier, with the lower IP as first member*/\nstatic __always_inline struct session_key get_key(uint32_t ip_a, uint32_t ip_b, uint16_t port_a, uint16_t port_b, uint8_t proto) {\n  if(ip_a < ip_b) {\n    struct session_key ret = {.saddr=ip_a, .daddr=ip_b, .sport=port_a, .dport=port_b, .proto=proto};\n    return ret;\n  } else {\n    struct session_key ret = {.saddr=ip_b, .daddr=ip_a, .sport=port_b, .dport=port_a, .proto=proto};\n    return ret;\n  }\n}\n\n/*Method to determine which member of the communication is the server*/\nstatic __always_inline __be32 heuristic_server(uint32_t src_ip, uint32_t dst_ip, uint16_t src_port, uint16_t dst_port, uint32_t *method, struct tcphdr *tcp) {\n  /*If Syn, then srcIp is the server*/\n  if(tcp && tcp->syn) {/*If source port < 1024, then srcIp is the server*/\n    *method = 1;\n    return tcp->ack? src_ip : dst_ip;\n  }\n  dst_port = bpf_htons(dst_port);\n  /*If destination port < 1024, then dstIp is the server*/\n  if(dst_port < 1024) {\n    *method = 2;\n    return dst_ip;\n  }\n  src_port = bpf_htons(src_port);\n  /*If source port < 1024, then srcIp is the server*/\n  if(src_port < 1024) {\n    *method = 2;\n    return src_ip;\n  }\n  *method = 3;\n  /*Otherwise, the lowest port is the server*/\n  return dst_port <= src_port ? dst_ip : src_ip;\n}\n\nstatic __always_inline void do_update(struct features *value, uint64_t len, uint64_t curr_time, bool cond) {\n  if (cond) {\n    value->n_packets += 1;\n    value->n_bytes += len;\n  } else {\n    value->n_packets_reverse += 1;\n    value->n_bytes_reverse += len;\n  }\n  value->alive_timestamp = curr_time;\n}\n\n\nstatic __always_inline int handler(struct CTXTYPE *ctx, struct pkt_metadata *md) {\n  void *data = (void *) (long) ctx->data;\n  void *data_end = (void *) (long) ctx->data_end;\n\n  /*Parsing L2*/\n  struct eth_hdr *ethernet = data;\n  if (data + sizeof(*ethernet) > data_end)\n    return PASS;\n\n  if (ethernet->proto != bpf_htons(ETH_P_IP))\n    return PASS;\n\n  /*Parsing L3*/\n  struct iphdr *ip = data + sizeof(struct eth_hdr);\n  if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n    return PASS;\n  if ((int) ip->version != 4)\n    return PASS;\n\n  /*Calculating ip header length\n   * value to multiply by 4 (SHL 2)\n   *e.g. ip->ihl = 5 ; TCP Header starts at = 5 x 4 byte = 20 byte */\n  uint8_t ip_header_len = ip->ihl << 2;\n\n  switch (ip->protocol) {\n    case IPPROTO_TCP: {\n      /*Parsing L4 TCP*/\n      struct tcphdr *tcp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) tcp + sizeof(*tcp) > data_end) {\n        return PASS;\n      }\n\n      uint64_t curr_time = get_time_epoch();\n      struct session_key key = get_key(ip->saddr, ip->daddr, tcp->source, tcp->dest, ip->protocol);\n\n      /*Check if match*/\n      struct features *value = SESSIONS_TRACKED_CRYPTO.lookup(&key);\n      if (!value) {\n        uint32_t method;\n        uint32_t server_ip = heuristic_server(ip->saddr, ip->daddr, tcp->source, tcp->dest, &method, tcp);\n        struct features zero = {.start_timestamp=curr_time, .method=method, .server_ip=server_ip};\n        SESSIONS_TRACKED_CRYPTO.insert(&key, &zero);\n        value = SESSIONS_TRACKED_CRYPTO.lookup(&key);\n        if (!value) {\n          return PASS;\n        }\n      }\n\n      /*Update current session*/\n      do_update(value, bpf_ntohs(ip->tot_len), curr_time, ip->saddr == key.saddr);\n      break;\n    }\n    case IPPROTO_UDP: {\n      /*Parsing L4 UDP*/\n      struct udphdr *udp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) udp + sizeof(*udp) > data_end) {\n        return PASS;\n      }\n\n      uint64_t curr_time = get_time_epoch();\n      struct session_key key = get_key(ip->saddr, ip->daddr, udp->source, udp->dest, ip->protocol);\n\n      /*Check if match*/\n      struct features *value = SESSIONS_TRACKED_CRYPTO.lookup(&key);\n      if (!value) {\n        uint32_t method;\n        uint32_t server_ip = heuristic_server(ip->saddr, ip->daddr, udp->source, udp->dest, &method, NULL);\n        struct features zero = {.start_timestamp=curr_time, .method=method, .server_ip=server_ip};\n        SESSIONS_TRACKED_CRYPTO.insert(&key, &zero);\n        value = SESSIONS_TRACKED_CRYPTO.lookup(&key);\n        if (!value) {\n          return PASS;\n        }\n      }\n\n      /*Update current session*/\n      do_update(value, bpf_ntohs(ip->tot_len), curr_time, ip->saddr == key.saddr);\n      break;\n    }\n    /*Ignored protocols*/\n    default: {\n      return PASS;\n    }\n  }\n\n  /* Here operations after the capture */\n  return PASS;\n}\n",
      "cp_function": "# Copyright 2020 DeChainy\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport time\nfrom typing import Dict, List, Tuple\n\nfrom dechainy.plugins import Plugin\nfrom dechainy.utility import ipv4_to_string, port_to_host_int, protocol_to_string\n\n# import json\n\n\ndef sumCPUValues(values: List[any], key: Tuple[any]) -> Tuple[any, List[any]]:\n    \"\"\"Function to aggregate all single values of the percpu map entry\n\n    Args:\n        values (List[any]): The values of the PERCPU map\n        key (Tuple[any]): The key under analysis\n\n    Returns:\n        Tuple[any, List[any]]: The aggregate value and the key in human-readable\n    \"\"\"\n    features = [0] * 8\n    # summing each cpu values\n    for value in values:\n        features[0] += value.n_packets\n        features[1] += value.n_packets_reverse\n        features[2] += value.n_bytes * 8\n        features[3] += value.n_bytes_reverse * 8\n        if value.method != 0:\n            features[4] = value.method\n        if value.alive_timestamp > features[5]:\n            features[5] = value.alive_timestamp\n        if value.start_timestamp > features[6]:\n            features[6] = value.start_timestamp\n        if value.server_ip != 0:\n            features[7] = value.server_ip\n    # modifying fields according to client-server and parsing Identifiers\n    if features[7] == key.saddr:\n        features[0], features[1], features[2], features[3] = features[1], features[0], features[3], features[2]\n        correct_key = (key.daddr, key.dport, key.saddr, key.sport, key.proto)\n    else:\n        correct_key = (key.saddr, key.sport, key.daddr, key.dport, key.proto)\n\n    features = features[:6] + [features[5] - features[6]]\n    correct_key = (\n        ipv4_to_string(correct_key[0]),\n        port_to_host_int(correct_key[1]),\n        ipv4_to_string(correct_key[2]),\n        port_to_host_int(correct_key[3]),\n        protocol_to_string(correct_key[4])\n    )\n    return correct_key, features\n\n\ndef makeDivision(i: float, j: float) -> float:\n    \"\"\"Function to perform division safely, even when 0 is given\n\n    Args:\n        i (float): The nominator\n        j (float): The denominator\n\n    Returns:\n        float: Result of the division, or -1 if not possible\n    \"\"\"\n    return i / j if j else -1\n\n\ndef reaction_function_rest(probe: Plugin) -> Dict[str, any]:\n    \"\"\"Function called when performing the REST request\n\n    Args:\n        probe (Plugin): The probe under analysis\n\n    Returns:\n        Dict[str, any]: The dictionary containing many computed values\n    \"\"\"\n    checkpoint_0 = time.time()\n\n    probe[\"ingress\"].trigger_read()\n    probe[\"egress\"].trigger_read()\n\n    data = []\n    checkpoint_1 = time.time()\n    for key, values in probe[\"ingress\"][\"SESSIONS_TRACKED_CRYPTO\"].items():\n        correct_key, features = sumCPUValues(values, key)\n        seconds = features[6] / 1000000000      # duration (s)\n        data.append({\"id\": correct_key, \"value\": [\n            features[5],                        # last timestamp\n            features[4],                        # server method\n            features[0],                        # client packets\n            features[1],                        # server packets\n            features[2],                        # client bits\n            features[3],                        # server bits\n            features[6],                        # duration (ns)\n            makeDivision(                       # client pkts per sec\n                features[0],\n                seconds),\n            makeDivision(                       # server pkts per sec\n                features[1],\n                seconds),\n            makeDivision(                       # client bits per sec\n                features[2],\n                seconds),\n            makeDivision(                       # server bits per sec\n                features[3],\n                seconds),\n            makeDivision(                       # client bits over pkts\n                features[2],\n                features[0]),\n            makeDivision(                       # server bits over pkts\n                features[3],\n                features[1]),\n            makeDivision(                       # server pkts over client pkts\n                features[1],\n                features[0]),\n            makeDivision(                       # server bits over client bits\n                features[3],\n                features[2])]})\n        del probe[\"ingress\"][\"SESSIONS_TRACKED_CRYPTO\"][key]\n    checkpoint_2 = time.time()\n\n    if not data:\n        return None\n\n    return {\"flows\": data, \"total_time\": checkpoint_2 - checkpoint_0,\n            \"controls_time\": checkpoint_1 - checkpoint_0,\n            \"ebpf_time\": checkpoint_2 - checkpoint_1}\n\n\ndef reaction_function(probe: Plugin):\n    \"\"\"Function periodically called locally, just to print the REST return\n\n    Args:\n        probe (Plugin): The probe under analysis\n\n    \"\"\"\n    ret = reaction_function_rest(probe)\n    if ret:\n        print(\n            'Got something!\\n\\t'\n            f'TIME total: {ret[\"total_time\"]} (s)\\n\\t'\n            f'TIME controls: {ret[\"controls_time\"]}\\n\\t'\n            f'TIME ebpf extraction + parse: {ret[\"ebpf_time\"]} (s)\\n\\t'\n            f'Sessions: {len(ret[\"flows\"])}', flush=True)\n        # print(json.dumps(ret[\"flows\"], indent=2))\n    else:\n        print('Got nothing ...', flush=True)\n"
    }
  ],
  "server": {
    "address": "0.0.0.0",
    "port": 8080
  }
}